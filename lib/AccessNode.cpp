#include "llvm/Analysis/LoopInfo.h"
#include "llvm/Analysis/ScalarEvolutionExpressions.h"

#include "llvm/IR/Dominators.h"

#include "AccessNode.h"
#include "InductionLoopVisitor.h"

using namespace llvm;

namespace offload {

bool AccessNode::hasIndirection(Instruction *Inst) {
  // don't leave the loop we started from
  if (!LoopPtr->contains(Inst))
    return false;
  // avoid endless recursion
  if (Visited.contains(Inst))
    return false;
  if (Inst != LoadPtr) {
    if (isa<llvm::LoadInst>(Inst)) {
      LoadPtr->print(errs());
      errs() << " has indirection, its Address is generated by ";
      Inst->print(errs());
      errs() << "\n";
      return true;
    }
  }
  Visited.insert(Inst);
  bool CombinedRecursions = false;
  // iterate over Operators
  for (auto OpIter = Inst->op_begin(); OpIter != Inst->op_end(); OpIter++) {
    auto Use = OpIter->get();
    auto *InsPtr = dyn_cast<Instruction>(Use);
    if (InsPtr)
      CombinedRecursions = (CombinedRecursions || hasIndirection(InsPtr));
  }
  return CombinedRecursions;
}

// this constructor does a lot of the analysis to create the information
// contained in AccessNode: Regularity of Access Insertion Point for
// LoopNodeTree Maybe SCEV Expression for multipliers - for now just constant
// multiplier based on nesting level
AccessNode::AccessNode(Loop *LoopPtr, LoadInst *LoadPtr, ScalarEvolution *SE,
                       DominatorTree *DT)
    : LoopPtr(LoopPtr), LoadPtr(LoadPtr), SE(SE), DT(DT) {
  // discern Regularity
  Regular = true;
  Regular = !(hasIndirection(LoadPtr));
  // Visited is a side-effect of hasIndirection()
  Visited.clear();

  llvm::BasicBlock *Latch = LoopPtr->getLoopLatch();
  if (Latch) {
    if (!(DT->dominates(LoadPtr, Latch))) {
      Regular = false;
      LoadPtr->print(errs());
      errs() << " is conditional"
             << "\n";
    }
  }

  // create vector of all loops with induction-dependance to load
  SmallVector<const Loop *, 4> InductionLoops;
  InductionLoopVisitor IndLoopV(InductionLoops);
  SCEVTraversal<InductionLoopVisitor> SCEVTraverser =
      SCEVTraversal<InductionLoopVisitor>(IndLoopV);
  Value *GEPPtr = LoadPtr->getPointerOperand();
  const SCEV *GEPPtrSCEV = SE->getSCEV(GEPPtr);
  SCEVTraverser.visitAll(GEPPtrSCEV);
  // start with deepest Loop containing Load
  // ascend loops until first loop is found with no induction-dependency on load
  TemporalReuse = false;
  Loop *LoopTraversePtr = LoopPtr;
  FirstNonInductionLoop = LoopPtr;
  bool isInduction = true;
  while (isInduction) {
    isInduction = false;
    for (auto IndLoop : InductionLoops) {
      if (IndLoop == LoopTraversePtr) {
        LoopTraversePtr = FirstNonInductionLoop->getParentLoop();
        if (LoopTraversePtr) {
          FirstNonInductionLoop = LoopTraversePtr;
          isInduction = true;
        } else {
          // we have reached the TLL
          TemporalReuse = false;
        }
        break;
      }
    }
  }
  assert(FirstNonInductionLoop->contains(LoadPtr) &&
         "Load not in FirstNonInductionLoop, something went wrong");
  // factor in induction loops
  TripcountFactor = 1;
  LoopTraversePtr = LoopPtr;
  while (LoopTraversePtr != FirstNonInductionLoop) {
    TripcountFactor = TripcountFactor * LoopFactor;
    LoopTraversePtr = LoopTraversePtr->getParentLoop();
  }
}
bool AccessNode::isRegular() { return Regular; }
LoadInst *AccessNode::getLoadPtr() { return LoadPtr; }
Loop *AccessNode::getFirstNonInduction() { return FirstNonInductionLoop; }
float AccessNode::getTripcountFactor() { return TripcountFactor; }
// check if this node and other node's AccessInst have same PointerOperand
bool AccessNode::isReducible(std::shared_ptr<AccessNode> OtherNode) {
  LoadInst *OtherLoadPtr = OtherNode->getLoadPtr();
  Value *PtrOp1 = LoadPtr->getPointerOperand();
  Value *PtrOp2 = OtherLoadPtr->getPointerOperand();
  if (PtrOp1 == PtrOp2) {
    return true;
  }
  return false;
}
} // namespace offload